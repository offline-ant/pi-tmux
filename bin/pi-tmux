#!/usr/bin/env bash
set -euo pipefail

LOCK_DIR="/tmp/pi-semaphores"
STATE_DIR="/tmp/pi-tmux-state"
IDLE_PREFIX="idle:"

sanitize_name() {
  printf '%s' "${1:-}" | tr -cd '[:alnum:]._-'
}

require_tmux() {
  if [[ -z "${TMUX:-}" ]]; then
    echo "error: not running inside a tmux session (TMUX is not set)" >&2
    exit 1
  fi
}

ensure_lock_dir() {
  mkdir -p "$LOCK_DIR"
  chmod 0777 "$LOCK_DIR" 2>/dev/null || true
}

ensure_state_dir() {
  mkdir -p "$STATE_DIR"
  chmod 0777 "$STATE_DIR" 2>/dev/null || true
}

coding_agent_marker_path() {
  printf '%s/coding-agent.%s' "$STATE_DIR" "$1"
}

last_warned_input_path() {
  printf '%s/last-warned-input.%s' "$STATE_DIR" "$1"
}

mark_coding_agent_lock() {
  local name="$1"
  ensure_state_dir
  : > "$(coding_agent_marker_path "$name")"
}

clear_coding_agent_state() {
  local name="$1"
  rm -f -- "$(coding_agent_marker_path "$name")" "$(last_warned_input_path "$name")"
}

is_coding_agent_target() {
  local target="${1:-}"
  [[ "$target" != %* ]] || return 1

  local safe_name
  safe_name="$(sanitize_name "$target")"
  [[ -n "$safe_name" ]] || return 1

  [[ -e "$(coding_agent_marker_path "$safe_name")" ]]
}

detect_pi_input_text() {
  local captured="${1:-}"
  printf '%s\n' "$captured" | awk '
    {
      lines[NR] = $0
    }
    END {
      topSep = 0
      bottomSep = 0

      for (i = 1; i <= NR; i++) {
        line = lines[i]
        trimmed = line
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", trimmed)
        if (length(trimmed) >= 10 && trimmed ~ /^─+$/) {
          topSep = bottomSep
          bottomSep = i
        }
      }

      if (topSep == 0 || bottomSep == 0 || bottomSep <= topSep) {
        exit
      }

      out = ""
      for (i = topSep + 1; i < bottomSep; i++) {
        line = lines[i]
        gsub(/\033\[[0-9;]*m/, "", line)
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
        if (line == "" || line == ">") {
          continue
        }

        if (out != "") {
          out = out "\n"
        }
        out = out line
      }

      sub(/^>[[:space:]]?/, "", out)
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", out)

      if (length(out) > 0) {
        printf "%s", out
      }
    }
  '
}

lock_path() {
  printf '%s/%s' "$LOCK_DIR" "$1"
}

idle_path() {
  printf '%s/%s%s' "$LOCK_DIR" "$IDLE_PREFIX" "$1"
}

find_unique_lock_name() {
  local base="$1"
  local candidate="$base"
  local n=2

  while [[ -e "$(lock_path "$candidate")" || -e "$(idle_path "$candidate")" ]]; do
    candidate="${base}-${n}"
    n=$((n + 1))
    if (( n > 1000 )); then
      candidate="${base}-$$"
      break
    fi
  done

  printf '%s' "$candidate"
}

resolve_pane() {
  local target="${1:-}"
  [[ -n "$target" ]] || { echo "error: missing target" >&2; return 1; }

  if [[ "$target" == %* ]]; then
    printf '%s' "$target"
    return
  fi

  local name
  name="$(sanitize_name "$target")"
  [[ -n "$name" ]] || { echo "error: invalid target name" >&2; return 1; }

  local path
  path="$(lock_path "$name")"
  if [[ ! -e "$path" ]]; then
    path="$(idle_path "$name")"
  fi

  if [[ ! -e "$path" ]]; then
    echo "error: lock '$name' not found" >&2
    return 1
  fi

  local pane
  pane="$(head -n 1 "$path" 2>/dev/null || true)"
  if [[ -z "$pane" || "$pane" != %* ]]; then
    echo "error: lock '$name' does not contain a valid pane id" >&2
    return 1
  fi

  printf '%s' "$pane"
}

strip_startup_help() {
  awk '
    BEGIN { skip_controls=0; seen_version=0; skip_ext=0 }
    {
      line=$0

      if (skip_controls) {
        if (line ~ /^[[:space:]]*$/) { skip_controls=0 }
        next
      }

      if (skip_ext) {
        if (line ~ /^[[:space:]]*$/) { skip_ext=0 }
        next
      }

      if (!seen_version && line ~ /^[[:space:]]*pi v[0-9]+\.[0-9]+\.[0-9]+/) {
        seen_version=1
        print line
        skip_controls=1
        next
      }

      if (line ~ /^[[:space:]]*\[Extensions\]/) {
        skip_ext=1
        next
      }

      print line
    }
  '
}

cmd_bash() {
  require_tmux
  ensure_lock_dir

  local requested_name="${1:-}"
  shift || true
  [[ -n "$requested_name" ]] || { echo "error: bash requires <lock-name>" >&2; return 1; }

  local safe_name
  safe_name="$(sanitize_name "$requested_name")"
  [[ -n "$safe_name" ]] || { echo "error: invalid lock name" >&2; return 1; }

  local lock_name
  lock_name="$(find_unique_lock_name "$safe_name")"

  local command="${*:-bash}"
  local wrapped_command
  wrapped_command="if ( ${command} ); then status=0; else status=\$?; fi; rm -f '$(lock_path "$lock_name")'; printf '%s\n' \"\${TMUX_PANE:-}\" > '$(idle_path "$lock_name")'; exit \$status"

  local pane_id
  if ! pane_id="$(tmux new-window -n "$lock_name" -d -P -F '#{pane_id}' -e "PI_LOCK_NAME=$lock_name" -- bash -lc "$wrapped_command" 2>&1)"; then
    echo "error: failed to create tmux pane: $pane_id" >&2
    return 1
  fi

  printf '%s\n' "$pane_id" > "$(lock_path "$lock_name")"
  tmux set-option -g remain-on-exit on >/dev/null 2>&1 || true

  echo "Created '$lock_name'"
  echo "Command: $command"

  if [[ "$lock_name" != "$safe_name" ]]; then
    echo
    echo "⚠️  WARNING: Lock name '$safe_name' was already in use — renamed to '$lock_name'."
    echo "   Use semaphore_wait('$lock_name') to wait for this pane, NOT '$safe_name'."
  fi
}

is_pane_dead() {
  local pane="${1:-}"
  [[ -n "$pane" ]] || return 1

  local dead
  dead="$(tmux display-message -p -t "$pane" '#{pane_dead}' 2>/dev/null || true)"
  [[ "$dead" == "1" ]]
}

cleanup_target_mapping() {
  local target="${1:-}"
  if [[ "$target" != %* ]]; then
    local safe_name
    safe_name="$(sanitize_name "$target")"
    rm -f -- "$(lock_path "$safe_name")" "$(idle_path "$safe_name")"
    clear_coding_agent_state "$safe_name"
  fi
}

cmd_capture() {
  require_tmux

  local target="${1:-}"
  local lines="${2:-500}"
  [[ -n "$target" ]] || { echo "error: capture requires <lock-name|pane-id>" >&2; return 1; }

  local pane
  pane="$(resolve_pane "$target")"

  local output
  output="$(tmux capture-pane -t "$pane" -p -S "-${lines}")"

  # Match previous TS behavior: strip startup controls block and [Extensions] block.
  output="$(printf '%s\n' "$output" | strip_startup_help)"

  local pane_dead=0
  if is_pane_dead "$pane"; then
    pane_dead=1
  fi

  # Match previous TS behavior: dead panes often contain huge whitespace blocks
  # before the final "Pane is dead (...)" line. Normalize whitespace only then.
  if (( pane_dead )) || printf '%s\n' "$output" | grep -q "Pane is dead ("; then
    output="$(printf '%s\n' "$output" | awk '
      { lines[NR] = $0 }
      END {
        start = 1
        while (start <= NR && lines[start] ~ /^[[:space:]]*$/) start++
        end = NR
        while (end >= start && lines[end] ~ /^[[:space:]]*$/) end--

        prevBlank = 0
        for (i = start; i <= end; i++) {
          isBlank = (lines[i] ~ /^[[:space:]]*$/)
          if (isBlank && prevBlank) continue
          print lines[i]
          prevBlank = isBlank
        }
      }
    ')"
  fi

  if (( pane_dead )); then
    tmux kill-pane -t "$pane" >/dev/null 2>&1 || true
    cleanup_target_mapping "$target"
  fi

  printf '%s\n' "$output"
}

cmd_send() {
  require_tmux

  local enter=1
  local target="${1:-}"
  shift || true
  [[ -n "$target" ]] || { echo "error: send requires <lock-name|pane-id> <text...>" >&2; return 1; }

  if [[ "${1:-}" == "--no-enter" ]]; then
    enter=0
    shift || true
  fi

  [[ $# -gt 0 ]] || { echo "error: send requires text" >&2; return 1; }

  local text="$*"
  local pane
  pane="$(resolve_pane "$target")"

  if (( enter )) && is_coding_agent_target "$target"; then
    local safe_name
    safe_name="$(sanitize_name "$target")"

    local captured existing_input warned_path previously_warned
    captured="$(tmux capture-pane -t "$pane" -p -S -50 2>/dev/null || true)"
    existing_input="$(detect_pi_input_text "$captured")"
    warned_path="$(last_warned_input_path "$safe_name")"

    if [[ -n "$existing_input" ]]; then
      previously_warned=""
      if [[ -e "$warned_path" ]]; then
        previously_warned="$(<"$warned_path")"
      fi

      if [[ "$previously_warned" == "$existing_input" ]]; then
        rm -f -- "$warned_path"
      else
        ensure_state_dir
        printf '%s' "$existing_input" > "$warned_path"
        echo "Warning: The pi input box in '$safe_name' already contains text:" >&2
        echo >&2
        printf '  "%s"\n' "$existing_input" >&2
        echo >&2
        echo "A human may be typing. The send was NOT executed." >&2
        echo "Retry tmux-send if this text is expected." >&2
        return 2
      fi
    else
      rm -f -- "$warned_path"
    fi
  fi

  if (( enter )); then
    tmux send-keys -t "$pane" "$text" Enter
  else
    tmux send-keys -t "$pane" "$text"
  fi

  local display_target="$target"
  if [[ "$target" == %* ]]; then
    display_target="$pane"
  fi

  local enter_suffix=""
  [[ $enter -eq 1 ]] && enter_suffix=" [Enter]"
  echo "Sent to '$display_target': $text$enter_suffix"

  if [[ "$target" != %* ]]; then
    echo "IMPORTANT: To wait for completion, call semaphore_wait with name '$display_target'."
    echo "If this command launches a nested pi (for example ../user-emulation/run), wait on the inner agent lock instead (for example the username lock)."
  fi
}

cmd_kill() {
  require_tmux

  local target="${1:-}"
  [[ -n "$target" ]] || { echo "error: kill requires <lock-name|pane-id>" >&2; return 1; }

  local pane
  pane="$(resolve_pane "$target")"

  tmux kill-pane -t "$pane"

  local display_target="$target"
  if [[ "$target" != %* ]]; then
    local safe_name
    safe_name="$(sanitize_name "$target")"
    cleanup_target_mapping "$safe_name"
    display_target="$safe_name"
  else
    display_target="$pane"
  fi

  echo "Killed '$display_target'."
}

cmd_coding_agent() {
  require_tmux
  ensure_lock_dir

  local requested_name="${1:-}"
  local folder="${2:-}"
  shift 2 || true

  [[ -n "$requested_name" ]] || { echo "error: coding-agent requires <lock-name> <folder> [pi args...]" >&2; return 1; }
  [[ -n "$folder" ]] || { echo "error: coding-agent requires <lock-name> <folder> [pi args...]" >&2; return 1; }

  local safe_name
  safe_name="$(sanitize_name "$requested_name")"
  [[ -n "$safe_name" ]] || { echo "error: invalid lock name" >&2; return 1; }

  local lock_name
  lock_name="$(find_unique_lock_name "$safe_name")"

  local pi_args="$*"
  local command="pi"
  if [[ -n "$pi_args" ]]; then
    command="pi $pi_args"
  fi

  local wrapped_command
  wrapped_command="if ( ${command} ); then status=0; else status=\$?; fi; rm -f '$(lock_path "$lock_name")'; printf '%s\n' \"\${TMUX_PANE:-}\" > '$(idle_path "$lock_name")'; exit \$status"

  local pane_id
  if ! pane_id="$(tmux new-window -n "$lock_name" -d -P -F '#{pane_id}' -e "PI_LOCK_NAME=$lock_name" -c "$folder" -- bash -lc "$wrapped_command" 2>&1)"; then
    echo "error: failed to create coding-agent pane: $pane_id" >&2
    return 1
  fi

  # Create immediate lock->pane mapping so send/capture/kill/wait work before first prompt.
  printf '%s\n' "$pane_id" > "$(lock_path "$lock_name")"
  mark_coding_agent_lock "$lock_name"

  tmux set-option -g remain-on-exit on >/dev/null 2>&1 || true

  echo "Pane '$lock_name' created. Waiting for pi to start..." >&2

  local start now elapsed
  start="$(date +%s)"
  local output=""

  while true; do
    output="$(tmux capture-pane -t "$pane_id" -p -S -500 || true)"
    local non_empty
    non_empty="$(printf '%s\n' "$output" | awk 'NF{c++} END{print c+0}')"
    if (( non_empty > 10 )); then
      break
    fi

    now="$(date +%s)"
    elapsed=$((now - start))
    if (( elapsed >= 5 )); then
      break
    fi

    sleep 0.3
  done

  output="$(printf '%s\n' "$output" | strip_startup_help)"

  echo "Pi agent '$lock_name' started in $folder."
  echo
  echo "Startup output:"
  printf '%s\n' "${output:-'(empty)'}"
  echo
  echo "Use send/capture/kill with '$lock_name'."

  if [[ "$lock_name" != "$safe_name" ]]; then
    echo
    echo "⚠️  WARNING: Lock name '$safe_name' was already in use — renamed to '$lock_name'."
    echo "   Use semaphore_wait('$lock_name') to wait for this pane, NOT '$safe_name'."
  fi
}

cmd_list() {
  require_tmux
  tmux list-panes -a -F '#{pane_id} #{session_name}:#{window_index}.#{pane_index} #{pane_current_command}'
}

usage() {
  cat <<'EOF'
Usage:
  pi-tmux bash <lock-name> [command...]
  pi-tmux capture <lock-name|pane-id> [lines]
  pi-tmux send <lock-name|pane-id> [--no-enter] <text...>
  pi-tmux kill <lock-name|pane-id>
  pi-tmux coding-agent <lock-name> <folder> [pi args...]
  pi-tmux list
EOF
}

main() {
  local cmd="${1:-}"
  shift || true

  case "$cmd" in
    bash) cmd_bash "$@" ;;
    capture) cmd_capture "$@" ;;
    send) cmd_send "$@" ;;
    kill) cmd_kill "$@" ;;
    coding-agent) cmd_coding_agent "$@" ;;
    list) cmd_list "$@" ;;
    -h|--help|help|"") usage ;;
    *)
      echo "error: unknown command: $cmd" >&2
      usage >&2
      return 1
      ;;
  esac
}

main "$@"
