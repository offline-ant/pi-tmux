#!/usr/bin/env bash
set -euo pipefail

LOCK_DIR="/tmp/pi-semaphores"
STATE_DIR="/tmp/pi-tmux-state"
STREAM_DIR="/tmp/pi-tmux-streams"
IDLE_PREFIX="idle:"

sanitize_name() {
  printf '%s' "${1:-}" | tr -cd '[:alnum:]._-'
}

require_tmux() {
  if [[ -z "${TMUX:-}" ]]; then
    echo "error: not running inside a tmux session (TMUX is not set)" >&2
    exit 1
  fi
}

ensure_lock_dir() {
  mkdir -p "$LOCK_DIR"
  chmod 0777 "$LOCK_DIR" 2>/dev/null || true
}

ensure_state_dir() {
  mkdir -p "$STATE_DIR"
  chmod 0777 "$STATE_DIR" 2>/dev/null || true
}

coding_agent_marker_path() {
  printf '%s/coding-agent.%s' "$STATE_DIR" "$1"
}

last_warned_input_path() {
  printf '%s/last-warned-input.%s' "$STATE_DIR" "$1"
}

mark_coding_agent_lock() {
  local name="$1"
  ensure_state_dir
  : > "$(coding_agent_marker_path "$name")"
}

clear_coding_agent_state() {
  local name="$1"
  rm -f -- "$(coding_agent_marker_path "$name")" "$(last_warned_input_path "$name")"
}

is_coding_agent_target() {
  local target="${1:-}"
  [[ "$target" != %* ]] || return 1

  local safe_name
  safe_name="$(sanitize_name "$target")"
  [[ -n "$safe_name" ]] || return 1

  [[ -e "$(coding_agent_marker_path "$safe_name")" ]]
}

detect_pi_input_text() {
  local captured="${1:-}"
  printf '%s\n' "$captured" | awk '
    {
      lines[NR] = $0
    }
    END {
      topSep = 0
      bottomSep = 0

      for (i = 1; i <= NR; i++) {
        line = lines[i]
        trimmed = line
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", trimmed)
        if (length(trimmed) >= 10 && trimmed ~ /^─+$/) {
          topSep = bottomSep
          bottomSep = i
        }
      }

      if (topSep == 0 || bottomSep == 0 || bottomSep <= topSep) {
        exit
      }

      out = ""
      for (i = topSep + 1; i < bottomSep; i++) {
        line = lines[i]
        gsub(/\033\[[0-9;]*m/, "", line)
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
        if (line == "" || line == ">") {
          continue
        }

        if (out != "") {
          out = out "\n"
        }
        out = out line
      }

      sub(/^>[[:space:]]?/, "", out)
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", out)

      if (length(out) > 0) {
        printf "%s", out
      }
    }
  '
}

lock_path() {
  printf '%s/%s' "$LOCK_DIR" "$1"
}

idle_path() {
  printf '%s/%s%s' "$LOCK_DIR" "$IDLE_PREFIX" "$1"
}

find_unique_lock_name() {
  local base="$1"
  local candidate="$base"
  local n=2

  while [[ -e "$(lock_path "$candidate")" || -e "$(idle_path "$candidate")" ]]; do
    candidate="${base}-${n}"
    n=$((n + 1))
    if (( n > 1000 )); then
      candidate="${base}-$$"
      break
    fi
  done

  printf '%s' "$candidate"
}

resolve_pane() {
  local target="${1:-}"
  [[ -n "$target" ]] || { echo "error: missing target" >&2; return 1; }

  if [[ "$target" == %* ]]; then
    printf '%s' "$target"
    return
  fi

  local name
  name="$(sanitize_name "$target")"
  [[ -n "$name" ]] || { echo "error: invalid target name" >&2; return 1; }

  local path
  path="$(lock_path "$name")"
  if [[ ! -e "$path" ]]; then
    path="$(idle_path "$name")"
  fi

  if [[ ! -e "$path" ]]; then
    echo "error: lock '$name' not found" >&2
    return 1
  fi

  local pane
  pane="$(head -n 1 "$path" 2>/dev/null || true)"
  if [[ -z "$pane" || "$pane" != %* ]]; then
    echo "error: lock '$name' does not contain a valid pane id" >&2
    return 1
  fi

  printf '%s' "$pane"
}

strip_startup_help() {
  awk '
    BEGIN { skip_controls=0; seen_version=0; skip_ext=0 }
    {
      line=$0

      if (skip_controls) {
        if (line ~ /^[[:space:]]*$/) { skip_controls=0 }
        next
      }

      if (skip_ext) {
        if (line ~ /^[[:space:]]*$/) { skip_ext=0 }
        next
      }

      if (!seen_version && line ~ /^[[:space:]]*pi v[0-9]+\.[0-9]+\.[0-9]+/) {
        seen_version=1
        print line
        skip_controls=1
        next
      }

      if (line ~ /^[[:space:]]*\[Extensions\]/) {
        skip_ext=1
        next
      }

      print line
    }
  '
}

cmd_bash() {
  require_tmux
  ensure_lock_dir

  local requested_name="${1:-}"
  shift || true
  [[ -n "$requested_name" ]] || { echo "error: bash requires <lock-name>" >&2; return 1; }

  local safe_name
  safe_name="$(sanitize_name "$requested_name")"
  [[ -n "$safe_name" ]] || { echo "error: invalid lock name" >&2; return 1; }

  local lock_name
  lock_name="$(find_unique_lock_name "$safe_name")"

  local command="${*:-bash}"
  local wrapped_command
  wrapped_command="if ( ${command} ); then status=0; else status=\$?; fi; rm -f '$(lock_path "$lock_name")'; printf '%s\n' \"\${TMUX_PANE:-}\" > '$(idle_path "$lock_name")'; exit \$status"

  local pane_id
  if ! pane_id="$(tmux new-window -n "$lock_name" -d -P -F '#{pane_id}' -e "PI_LOCK_NAME=$lock_name" -- bash -lc "$wrapped_command" 2>&1)"; then
    echo "error: failed to create tmux pane: $pane_id" >&2
    return 1
  fi

  printf '%s\n' "$pane_id" > "$(lock_path "$lock_name")"
  tmux set-option -g remain-on-exit on >/dev/null 2>&1 || true

  echo "Created '$lock_name'"
  echo "Command: $command"

  if [[ "$lock_name" != "$safe_name" ]]; then
    echo
    echo "⚠️  WARNING: Lock name '$safe_name' was already in use — renamed to '$lock_name'."
    echo "   Use semaphore_wait('$lock_name') to wait for this pane, NOT '$safe_name'."
  fi
}

is_pane_in_copy_mode() {
  local pane="${1:-}"
  [[ -n "$pane" ]] || return 1

  local mode
  mode="$(tmux display-message -p -t "$pane" '#{pane_in_mode}' 2>/dev/null || true)"
  [[ "$mode" == "1" ]]
}

wait_for_copy_mode_exit() {
  local pane="${1:-}"
  local timeout="${2:-30}"

  if ! is_pane_in_copy_mode "$pane"; then
    return 0
  fi

  # Alert the user with a bell (write to pane tty to avoid exiting copy mode)
  local pane_tty
  pane_tty="$(tmux display-message -t "$pane" -p '#{pane_tty}' 2>/dev/null || true)"
  if [[ -n "$pane_tty" && -w "$pane_tty" ]]; then
    printf '\a' > "$pane_tty"
  fi

  local start now elapsed
  start="$(date +%s)"

  while is_pane_in_copy_mode "$pane"; do
    now="$(date +%s)"
    elapsed=$((now - start))
    if (( elapsed >= timeout )); then
      # Forcibly cancel copy mode
      tmux send-keys -t "$pane" -X cancel 2>/dev/null || true
      break
    fi
    sleep 0.5
  done

  return 0
}

is_pane_dead() {
  local pane="${1:-}"
  [[ -n "$pane" ]] || return 1

  local dead
  dead="$(tmux display-message -p -t "$pane" '#{pane_dead}' 2>/dev/null || true)"
  [[ "$dead" == "1" ]]
}

stream_path() {
  printf '%s/%s' "$STREAM_DIR" "$1"
}

ensure_stream_dir() {
  mkdir -p "$STREAM_DIR"
  chmod 0777 "$STREAM_DIR" 2>/dev/null || true
}

# Find a unique watch lock name: <name>:watch, <name>:watch-2, ...
find_unique_watch_lock() {
  local name="$1"
  local candidate="${name}:watch"
  local n=2

  while [[ -e "$(lock_path "$candidate")" ]]; do
    candidate="${name}:watch-${n}"
    n=$((n + 1))
    if (( n > 1000 )); then
      candidate="${name}:watch-$$"
      break
    fi
  done

  printf '%s' "$candidate"
}

# Clean up watch locks and stream infrastructure for a pane
cleanup_watch_state() {
  local name="${1:-}"
  [[ -n "$name" ]] || return 0

  # Remove all watch locks for this pane (<name>:watch, <name>:watch-2, ...)
  local f
  for f in "$LOCK_DIR/${name}:watch" "$LOCK_DIR/${name}:watch-"*; do
    [[ -e "$f" ]] && rm -f -- "$f"
  done

  # Stop pipe-pane and remove stream file
  local stream
  stream="$(stream_path "$name")"
  if [[ -e "$stream" ]]; then
    # Resolve pane to stop pipe-pane (best-effort, pane may already be dead)
    local pane
    pane="$(resolve_pane "$name" 2>/dev/null || true)"
    if [[ -n "$pane" ]]; then
      tmux pipe-pane -t "$pane" 2>/dev/null || true
    fi
    rm -f -- "$stream"
  fi

  # Kill any lingering watcher processes for this stream
  pkill -f "tail -f $(stream_path "$name")" 2>/dev/null || true
}

cleanup_target_mapping() {
  local target="${1:-}"
  if [[ "$target" != %* ]]; then
    local safe_name
    safe_name="$(sanitize_name "$target")"
    cleanup_watch_state "$safe_name"
    rm -f -- "$(lock_path "$safe_name")" "$(idle_path "$safe_name")"
    # Clean up context alert lock if it exists
    rm -f -- "$(lock_path "${safe_name}:context")"
    clear_coding_agent_state "$safe_name"
  fi
}

cmd_capture() {
  require_tmux

  local target="${1:-}"
  local lines="${2:-500}"
  [[ -n "$target" ]] || { echo "error: capture requires <lock-name|pane-id>" >&2; return 1; }

  local pane
  pane="$(resolve_pane "$target")"

  local output
  output="$(tmux capture-pane -t "$pane" -p -S "-${lines}")"

  # Match previous TS behavior: strip startup controls block and [Extensions] block.
  output="$(printf '%s\n' "$output" | strip_startup_help)"

  local pane_dead=0
  if is_pane_dead "$pane"; then
    pane_dead=1
  fi

  # Match previous TS behavior: dead panes often contain huge whitespace blocks
  # before the final "Pane is dead (...)" line. Normalize whitespace only then.
  if (( pane_dead )) || printf '%s\n' "$output" | grep -q "Pane is dead ("; then
    output="$(printf '%s\n' "$output" | awk '
      { lines[NR] = $0 }
      END {
        start = 1
        while (start <= NR && lines[start] ~ /^[[:space:]]*$/) start++
        end = NR
        while (end >= start && lines[end] ~ /^[[:space:]]*$/) end--

        prevBlank = 0
        for (i = start; i <= end; i++) {
          isBlank = (lines[i] ~ /^[[:space:]]*$/)
          if (isBlank && prevBlank) continue
          print lines[i]
          prevBlank = isBlank
        }
      }
    ')"
  fi

  if (( pane_dead )); then
    tmux kill-pane -t "$pane" >/dev/null 2>&1 || true
    cleanup_target_mapping "$target"
  fi

  printf '%s\n' "$output"
}

cmd_send() {
  require_tmux

  local enter=1
  local target="${1:-}"
  shift || true
  [[ -n "$target" ]] || { echo "error: send requires <lock-name|pane-id> <text...>" >&2; return 1; }

  if [[ "${1:-}" == "--no-enter" ]]; then
    enter=0
    shift || true
  fi

  [[ $# -gt 0 ]] || { echo "error: send requires text" >&2; return 1; }

  local text="$*"
  local pane
  pane="$(resolve_pane "$target")"

  if (( enter )) && is_coding_agent_target "$target"; then
    local safe_name
    safe_name="$(sanitize_name "$target")"

    local captured existing_input warned_path previously_warned
    captured="$(tmux capture-pane -t "$pane" -p -S -50 2>/dev/null || true)"
    existing_input="$(detect_pi_input_text "$captured")"
    warned_path="$(last_warned_input_path "$safe_name")"

    if [[ -n "$existing_input" ]]; then
      previously_warned=""
      if [[ -e "$warned_path" ]]; then
        previously_warned="$(<"$warned_path")"
      fi

      if [[ "$previously_warned" == "$existing_input" ]]; then
        rm -f -- "$warned_path"
      else
        ensure_state_dir
        printf '%s' "$existing_input" > "$warned_path"
        echo "Warning: The pi input box in '$safe_name' already contains text:" >&2
        echo >&2
        printf '  "%s"\n' "$existing_input" >&2
        echo >&2
        echo "A human may be typing. The send was NOT executed." >&2
        echo "Retry tmux-send if this text is expected." >&2
        return 2
      fi
    else
      rm -f -- "$warned_path"
    fi
  fi

  # Wait for copy mode to clear before sending keys
  wait_for_copy_mode_exit "$pane" 30

  if (( enter )); then
    tmux send-keys -t "$pane" "$text" Enter
  else
    tmux send-keys -t "$pane" "$text"
  fi

  local display_target="$target"
  if [[ "$target" == %* ]]; then
    display_target="$pane"
  fi

  local enter_suffix=""
  [[ $enter -eq 1 ]] && enter_suffix=" [Enter]"
  echo "Sent to '$display_target': $text$enter_suffix"

  if [[ "$target" != %* ]]; then
    echo "To wait, call semaphore_wait('$display_target')."
  fi
}

cmd_kill() {
  require_tmux

  local target="${1:-}"
  [[ -n "$target" ]] || { echo "error: kill requires <lock-name|pane-id>" >&2; return 1; }

  local pane
  pane="$(resolve_pane "$target")"

  tmux kill-pane -t "$pane"

  local display_target="$target"
  if [[ "$target" != %* ]]; then
    local safe_name
    safe_name="$(sanitize_name "$target")"
    cleanup_target_mapping "$safe_name"
    display_target="$safe_name"
  else
    display_target="$pane"
  fi

  echo "Killed '$display_target'."
}

cmd_coding_agent() {
  require_tmux
  ensure_lock_dir

  local requested_name="${1:-}"
  local folder="${2:-}"
  shift 2 || true

  [[ -n "$requested_name" ]] || { echo "error: coding-agent requires <lock-name> <folder> [pi args...]" >&2; return 1; }
  [[ -n "$folder" ]] || { echo "error: coding-agent requires <lock-name> <folder> [pi args...]" >&2; return 1; }

  # Parse optional --context-alert flag from remaining args
  local context_alert=""
  local pi_args_array=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --context-alert)
        shift
        context_alert="${1:-}"
        shift || true
        ;;
      --context-alert=*)
        context_alert="${1#*=}"
        shift
        ;;
      *)
        pi_args_array+=("$1")
        shift
        ;;
    esac
  done

  local safe_name
  safe_name="$(sanitize_name "$requested_name")"
  [[ -n "$safe_name" ]] || { echo "error: invalid lock name" >&2; return 1; }

  local lock_name
  lock_name="$(find_unique_lock_name "$safe_name")"

  local pi_args="${pi_args_array[*]:-}"
  local command="pi"
  if [[ -n "$pi_args" ]]; then
    command="pi $pi_args"
  fi

  # Build env flags for tmux new-window
  local env_flags=(-e "PI_LOCK_NAME=$lock_name")
  if [[ -n "$context_alert" ]]; then
    env_flags+=(-e "PI_CONTEXT_ALERT=$context_alert")
  fi

  local wrapped_command
  wrapped_command="if ( ${command} ); then status=0; else status=\$?; fi; rm -f '$(lock_path "$lock_name")'; printf '%s\n' \"\${TMUX_PANE:-}\" > '$(idle_path "$lock_name")'; exit \$status"

  local pane_id
  if ! pane_id="$(tmux new-window -n "$lock_name" -d -P -F '#{pane_id}' "${env_flags[@]}" -c "$folder" -- bash -lc "$wrapped_command" 2>&1)"; then
    echo "error: failed to create coding-agent pane: $pane_id" >&2
    return 1
  fi

  # Create immediate lock->pane mapping so send/capture/kill/wait work before first prompt.
  printf '%s\n' "$pane_id" > "$(lock_path "$lock_name")"
  mark_coding_agent_lock "$lock_name"

  # Create context alert lock immediately so supervisor can wait on it right away.
  local context_lock_name=""
  if [[ -n "$context_alert" ]]; then
    context_lock_name="${lock_name}:context"
    printf '%s\n' "$pane_id" > "$(lock_path "$context_lock_name")"
  fi

  tmux set-option -g remain-on-exit on >/dev/null 2>&1 || true

  echo "Pane '$lock_name' created. Waiting for pi to start..." >&2

  local start now elapsed
  start="$(date +%s)"
  local output=""

  while true; do
    output="$(tmux capture-pane -t "$pane_id" -p -S -500 || true)"
    local non_empty
    non_empty="$(printf '%s\n' "$output" | awk 'NF{c++} END{print c+0}')"
    if (( non_empty > 10 )); then
      break
    fi

    now="$(date +%s)"
    elapsed=$((now - start))
    if (( elapsed >= 5 )); then
      break
    fi

    sleep 0.3
  done

  output="$(printf '%s\n' "$output" | strip_startup_help)"

  echo "Pi agent '$lock_name' started in $folder."
  echo
  echo "Startup output:"
  printf '%s\n' "${output:-'(empty)'}"
  echo
  echo "Use send/capture/kill with '$lock_name'."

  if [[ -n "$context_lock_name" ]]; then
    echo "Context alert lock: '$context_lock_name' (releases when context >= ${context_alert}%)"
    echo "Wait for either: semaphore_wait(names=['$lock_name', '$context_lock_name'])"
  fi

  if [[ "$lock_name" != "$safe_name" ]]; then
    echo
    echo "⚠️  WARNING: Lock name '$safe_name' was already in use — renamed to '$lock_name'."
    echo "   Use semaphore_wait('$lock_name') to wait for this pane, NOT '$safe_name'."
  fi
}

cmd_watch() {
  require_tmux
  ensure_lock_dir
  ensure_stream_dir

  local target="${1:-}"
  local pattern="${2:-}"
  [[ -n "$target" ]] || { echo "error: watch requires <lock-name> <pattern>" >&2; return 1; }
  [[ -n "$pattern" ]] || { echo "error: watch requires <lock-name> <pattern>" >&2; return 1; }

  # Watch only works with named panes (need a stable name for lock/stream)
  [[ "$target" != %* ]] || { echo "error: watch requires a lock name, not a pane id" >&2; return 1; }

  local safe_name
  safe_name="$(sanitize_name "$target")"
  [[ -n "$safe_name" ]] || { echo "error: invalid target name" >&2; return 1; }

  local pane
  pane="$(resolve_pane "$target")"

  local watch_lock
  watch_lock="$(find_unique_watch_lock "$safe_name")"

  local stream
  stream="$(stream_path "$safe_name")"

  # Check if the pattern already matches in the current buffer
  local existing
  existing="$(tmux capture-pane -t "$pane" -p -S -500 2>/dev/null || true)"
  existing="$(printf '%s\n' "$existing" | sed 's/\x1b\[[0-9;]*[a-zA-Z]//g')"
  if printf '%s\n' "$existing" | grep -qE "$pattern" 2>/dev/null; then
    echo "Pattern already matched in existing output. No watch needed."
    return 0
  fi

  # Create the watch lock
  printf '%s\n' "$pane" > "$(lock_path "$watch_lock")"

  # Set up pipe-pane → stream file. Always re-set (no -o) in case a previous
  # pipe died. Replaces any existing pipe, which is fine — all watchers read
  # from the same stream file via tail -f regardless.
  tmux pipe-pane -O -t "$pane" "cat >> '${stream}'"

  # Ensure stream file exists (pipe-pane creates it on first write, but tail -f needs it now)
  touch "$stream"

  # Spawn watcher: tail -f | strip ANSI | grep -m1 → release lock
  # Uses process substitution so grep is not in the pipeline — when grep exits
  # execution continues immediately to rm. tail/sed linger until next write
  # triggers SIGPIPE, then self-clean.
  local watcher_script="${STREAM_DIR}/${watch_lock}.sh"
  local watch_lock_path
  watch_lock_path="$(lock_path "$watch_lock")"

  cat > "$watcher_script" <<'WATCHER_EOF'
#!/usr/bin/env bash
stream="$1"; lock="$2"; pattern="$3"; self="$4"
grep --line-buffered -m1 -qE "$pattern" \
  < <(tail -f "$stream" \
    | sed -u $'s/\x1b\\[[0-9;]*[a-zA-Z]//g; s/\x1b\\][^\x07]*\x07//g; s/\x1b(B//g')
rm -f "$lock" "$self"
WATCHER_EOF
  chmod +x "$watcher_script"
  nohup bash "$watcher_script" "$stream" "$watch_lock_path" "$pattern" "$watcher_script" >/dev/null 2>&1 &
  disown

  echo "Watch set on '$safe_name' for /$pattern/."
  echo "semaphore_wait on lock '$watch_lock' to be notified."
}

cmd_list() {
  require_tmux
  tmux list-panes -a -F '#{pane_id} #{session_name}:#{window_index}.#{pane_index} #{pane_current_command}'
}

usage() {
  cat <<'EOF'
Usage:
  pi-tmux bash <lock-name> [command...]
  pi-tmux capture <lock-name|pane-id> [lines]
  pi-tmux send <lock-name|pane-id> [--no-enter] <text...>
  pi-tmux kill <lock-name|pane-id>
  pi-tmux watch <lock-name> <pattern>
  pi-tmux coding-agent <lock-name> <folder> [pi args...]
  pi-tmux list
EOF
}

main() {
  local cmd="${1:-}"
  shift || true

  case "$cmd" in
    bash) cmd_bash "$@" ;;
    capture) cmd_capture "$@" ;;
    send) cmd_send "$@" ;;
    kill) cmd_kill "$@" ;;
    watch) cmd_watch "$@" ;;
    coding-agent) cmd_coding_agent "$@" ;;
    list) cmd_list "$@" ;;
    -h|--help|help|"") usage ;;
    *)
      echo "error: unknown command: $cmd" >&2
      usage >&2
      return 1
      ;;
  esac
}

main "$@"
